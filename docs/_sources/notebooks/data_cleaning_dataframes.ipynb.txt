{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Data Cleaning"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are numerous approaches of how to deal with daily tasks of cleaning data.\n",
    "\n",
    "For example (listing starts from most confusing way):\n",
    "\n",
    "* pandas way\n",
    "* slightly more advanced users might take advantage of the functional API\n",
    "* via pyjanitor package (inspired by the ease-of-use and expressiveness of the dplyr package of the R statistical language ecosystem)\n",
    "\n",
    "I always take the easy way out so we will focus on a consistent and expressive approach\n",
    "utilizing `pyjanitor`.\n",
    "\n",
    "So lets define it... `pyjanitor` is a Python implementation of the R package janitor, \n",
    "and provides a clean API for cleaning data.\n",
    "\n",
    "Interestingly we import pyjanitor as janitor for a reason.\n",
    "\n",
    "Afterwards we will inspect other methods two ways of doing things.\n",
    "\n",
    "I prefer having one way of doing common tasks rather then having a myriad of them which reduces fluency and introduces clutter.\n",
    "\n",
    "We are here to solve problems :)"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "## Readable and understandable code - chaining"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "I will always try to avoid the following two ways of writing code:\n",
    "\n",
    "** 1) MUTLIPLE OBJECT OPTION**\n",
    "eat(\n",
    "\n",
    "    slice(\n",
    "\n",
    "        bake(\n",
    "            \n",
    "            put(\n",
    "                pour(\n",
    "\n",
    "                    mix(ingredients),\n",
    "\n",
    "                    into=baking_form),\n",
    "\n",
    "                    into=oven),\n",
    "\n",
    "                time=30),\n",
    "                \n",
    "            pieces=6),\n",
    "        1)\n",
    "\n",
    "This first option is considered a “nested” option such that functions are nested \n",
    "within one another. Historically, this has been the traditional way of\n",
    "integrating code; however, it becomes extremely difficult to read what \n",
    "exactly the code is doing and it also becomes easier to make mistakes when \n",
    "making updates to your code. Although not in violation of the DRY principle1, \n",
    "it definitely violates the basic principle of readability and clarity, \n",
    "which makes communication of your analysis more difficult. To make things\n",
    "more readable, people often move to the following approach…\n",
    "\n",
    "** 2) NESTED OPTION**\n",
    "\n",
    "\n",
    "    it = mix(ingredients)\n",
    "\n",
    "    it = pour(it, into=baking_form)\n",
    "\n",
    "    it = put(it, into=oven)\n",
    "\n",
    "    it = bake(it, time=30)\n",
    "\n",
    "    it = slice(it, pieces=6)\n",
    "\n",
    "    it = eat(it, 1)\n",
    "\n",
    "This second option helps in making the data wrangling steps more explicit \n",
    "and obvious but definitely violates the DRY principle. By sequencing \n",
    "multiple functions in this way you are likely saving multiple outputs \n",
    "that are not very informative to you or others; rather, the only reason \n",
    "you save them is to insert them into the next function to eventually get the\n",
    "final output you desire. This inevitably creates unnecessary copies and wrecks \n",
    "havoc on properly managing your objects…basically it results in a global \n",
    "environment charlie foxtrot! \n",
    "\n",
    "**I WILL INSIST ON METHODS CHAINING (if and when python and pandas allows you)**\n",
    "\n",
    "To provide the same readability (or even better), we can use chaining of methods to string \n",
    "these arguments together without unnecessary object creation…\n",
    "\n",
    "The point of the chain is to help you write code in a way that is easier to read and understand. \n",
    "It is powerful tool for clearly expressing a sequence of multiple operations. \n",
    "\n",
    "    (ingredients\n",
    "\n",
    "        .mix()\n",
    "\n",
    "        .pour(into=baking_form)\n",
    "\n",
    "        .put(into=oven)\n",
    "\n",
    "        .bake(time=30)\n",
    "\n",
    "        .slice(pieces=6)\n",
    "    \n",
    "        .ear(1)\n",
    "    )\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Tabular Dataset - NPD well data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "#pd.set_option('display.max_columns', None)  \n",
    "import janitor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv(\"https://factpages.npd.no/ReportServer_npdpublic?/FactPages/TableView/wellbore_exploration_all&rs:Command=Render&rc:Toolbar=false&rc:Parameters=f&rs:Format=CSV&Top100=false&IpAddress=82.102.27.246&CultureCode=en\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>wlbWellboreName</th>\n      <th>wlbWell</th>\n      <th>wlbDrillingOperator</th>\n      <th>wlbProductionLicence</th>\n      <th>wlbPurpose</th>\n      <th>wlbStatus</th>\n      <th>wlbContent</th>\n      <th>wlbWellType</th>\n      <th>wlbSubSea</th>\n      <th>wlbEntryDate</th>\n      <th>...</th>\n      <th>wlbNpdidWellbore</th>\n      <th>dscNpdidDiscovery</th>\n      <th>fldNpdidField</th>\n      <th>fclNpdidFacilityDrilling</th>\n      <th>wlbNpdidWellboreReclass</th>\n      <th>prlNpdidProductionLicence</th>\n      <th>wlbNpdidSiteSurvey</th>\n      <th>wlbDateUpdated</th>\n      <th>wlbDateUpdatedMax</th>\n      <th>datesyncNPD</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>1/2-1</td>\n      <td>1/2-1</td>\n      <td>Phillips Petroleum Norsk AS</td>\n      <td>143</td>\n      <td>WILDCAT</td>\n      <td>P&amp;A</td>\n      <td>OIL</td>\n      <td>EXPLORATION</td>\n      <td>NO</td>\n      <td>20.03.1989</td>\n      <td>...</td>\n      <td>1382</td>\n      <td>43814.0</td>\n      <td>3437650.0</td>\n      <td>296245.0</td>\n      <td>0</td>\n      <td>21956.0</td>\n      <td>NaN</td>\n      <td>03.10.2019</td>\n      <td>03.10.2019</td>\n      <td>18.11.2019</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>1/2-2</td>\n      <td>1/2-2</td>\n      <td>Paladin Resources Norge AS</td>\n      <td>143 CS</td>\n      <td>WILDCAT</td>\n      <td>P&amp;A</td>\n      <td>OIL SHOWS</td>\n      <td>EXPLORATION</td>\n      <td>NO</td>\n      <td>14.12.2005</td>\n      <td>...</td>\n      <td>5192</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>278245.0</td>\n      <td>0</td>\n      <td>2424919.0</td>\n      <td>NaN</td>\n      <td>03.10.2019</td>\n      <td>03.10.2019</td>\n      <td>18.11.2019</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>1/3-1</td>\n      <td>1/3-1</td>\n      <td>A/S Norske Shell</td>\n      <td>011</td>\n      <td>WILDCAT</td>\n      <td>P&amp;A</td>\n      <td>GAS</td>\n      <td>EXPLORATION</td>\n      <td>NO</td>\n      <td>06.07.1968</td>\n      <td>...</td>\n      <td>154</td>\n      <td>43820.0</td>\n      <td>NaN</td>\n      <td>288604.0</td>\n      <td>0</td>\n      <td>20844.0</td>\n      <td>NaN</td>\n      <td>03.10.2019</td>\n      <td>03.10.2019</td>\n      <td>18.11.2019</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>1/3-2</td>\n      <td>1/3-2</td>\n      <td>A/S Norske Shell</td>\n      <td>011</td>\n      <td>WILDCAT</td>\n      <td>P&amp;A</td>\n      <td>DRY</td>\n      <td>EXPLORATION</td>\n      <td>NO</td>\n      <td>14.05.1969</td>\n      <td>...</td>\n      <td>165</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>288847.0</td>\n      <td>0</td>\n      <td>20844.0</td>\n      <td>NaN</td>\n      <td>03.10.2019</td>\n      <td>03.10.2019</td>\n      <td>18.11.2019</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>1/3-3</td>\n      <td>1/3-3</td>\n      <td>Elf Petroleum Norge AS</td>\n      <td>065</td>\n      <td>WILDCAT</td>\n      <td>P&amp;A</td>\n      <td>OIL</td>\n      <td>EXPLORATION</td>\n      <td>NO</td>\n      <td>22.08.1982</td>\n      <td>...</td>\n      <td>87</td>\n      <td>43826.0</td>\n      <td>1028599.0</td>\n      <td>288334.0</td>\n      <td>0</td>\n      <td>21316.0</td>\n      <td>NaN</td>\n      <td>03.10.2019</td>\n      <td>03.10.2019</td>\n      <td>18.11.2019</td>\n    </tr>\n  </tbody>\n</table>\n<p>5 rows × 87 columns</p>\n</div>",
      "text/plain": "  wlbWellboreName wlbWell          wlbDrillingOperator wlbProductionLicence  \\\n0           1/2-1   1/2-1  Phillips Petroleum Norsk AS                 143    \n1           1/2-2   1/2-2   Paladin Resources Norge AS               143 CS   \n2           1/3-1   1/3-1             A/S Norske Shell                 011    \n3           1/3-2   1/3-2             A/S Norske Shell                 011    \n4           1/3-3   1/3-3       Elf Petroleum Norge AS                 065    \n\n  wlbPurpose wlbStatus wlbContent  wlbWellType wlbSubSea wlbEntryDate  ...  \\\n0    WILDCAT       P&A        OIL  EXPLORATION        NO   20.03.1989  ...   \n1    WILDCAT       P&A  OIL SHOWS  EXPLORATION        NO   14.12.2005  ...   \n2    WILDCAT       P&A        GAS  EXPLORATION        NO   06.07.1968  ...   \n3    WILDCAT       P&A        DRY  EXPLORATION        NO   14.05.1969  ...   \n4    WILDCAT       P&A        OIL  EXPLORATION        NO   22.08.1982  ...   \n\n  wlbNpdidWellbore dscNpdidDiscovery fldNpdidField fclNpdidFacilityDrilling  \\\n0             1382           43814.0     3437650.0                 296245.0   \n1             5192               NaN           NaN                 278245.0   \n2              154           43820.0           NaN                 288604.0   \n3              165               NaN           NaN                 288847.0   \n4               87           43826.0     1028599.0                 288334.0   \n\n  wlbNpdidWellboreReclass  prlNpdidProductionLicence wlbNpdidSiteSurvey  \\\n0                       0                    21956.0                NaN   \n1                       0                  2424919.0                NaN   \n2                       0                    20844.0                NaN   \n3                       0                    20844.0                NaN   \n4                       0                    21316.0                NaN   \n\n  wlbDateUpdated  wlbDateUpdatedMax  datesyncNPD  \n0     03.10.2019         03.10.2019   18.11.2019  \n1     03.10.2019         03.10.2019   18.11.2019  \n2     03.10.2019         03.10.2019   18.11.2019  \n3     03.10.2019         03.10.2019   18.11.2019  \n4     03.10.2019         03.10.2019   18.11.2019  \n\n[5 rows x 87 columns]"
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "## Cleaning column names"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-20-5f25004e24f9>, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;36m  File \u001b[1;32m\"<ipython-input-20-5f25004e24f9>\"\u001b[1;36m, line \u001b[1;32m1\u001b[0m\n\u001b[1;33m    Lets list our columns names:\u001b[0m\n\u001b[1;37m            ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "Lets list our columns names:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "Index(['wellbore_name', 'well', 'drilling_operator', 'production_licence',\n       'purpose', 'status', 'content', 'well_type', 'sub_sea', 'entry_date',\n       'completion_date', 'field', 'drill_permit', 'discovery',\n       'discovery_wellbore', 'bottom_hole_temperature', 'site_survey',\n       'seismic_location', 'max_inclation', 'kelly_bush_elevation',\n       'final_vertical_depth', 'total_depth', 'water_depth', 'kick_off_point',\n       'age_at_td', 'formation_at_td', 'main_area', 'drilling_facility',\n       'facility_type_drilling', 'drilling_facility_fixed_or_moveable',\n       'licensing_activity', 'multilateral', 'purpose_planned', 'entry_year',\n       'completion_year', 'reclass_from_wellbore',\n       'reentry_exploration_activity', 'plot_symbol', 'formation_with_hc1',\n       'age_with_hc1', 'formation_with_hc2', 'age_with_hc2',\n       'formation_with_hc3', 'age_with_hc3', 'drilling_days', 'reentry',\n       'licence_target_name', 'plugged_abandon_date', 'plugged_date',\n       'geodetic_datum', 'ns_deg', 'ns_min', 'ns_sec', 'ns_code', 'ew_deg',\n       'ew_min', 'ew_sec', 'ew_code', 'ns_dec_deg', 'ew_des_deg', 'ns_utm',\n       'ew_utm', 'utm_zone', 'name_part1', 'name_part2', 'name_part3',\n       'name_part4', 'name_part5', 'name_part6', 'press_release_url',\n       'fact_page_url', 'fact_map_url', 'diskos_wellbore_type',\n       'diskos_wellbore_parent', 'wdss_qc_date', 'released_date',\n       'date_reclass', 'npdid_wellbore', 'dsc_npdid_discovery', 'npdid_field',\n       'npdid_facility_drilling', 'npdid_wellbore_reclass',\n       'prl_npdid_production_licence', 'npdid_site_survey', 'date_updated',\n       'date_updated_max', 'datesync_npd'],\n      dtype='object')"
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df.columns"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### str_replace - replace something with something"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We need to clean our column names so we make are subsequent workflows on dataframes\n",
    "as easy as it can get.\n",
    "\n",
    "**It is important that we wrap our chains of methods into parantheses** (why?) \n",
    "The second approach would be to end each line with a backslash. I find the first\n",
    "approach more elegant so I will use it.\n",
    "\n",
    "Remove wlb, fld, fcl prefixes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.columns = (\n",
    "    df.columns\n",
    "        .str.replace(\"wlb\", \"\")\n",
    "        .str.replace(\"fld\", \"\")\n",
    "        .str.replace(\"fcl\", \"\")\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "Index(['wellbore_name', 'well', 'drilling_operator', 'production_licence',\n       'purpose', 'status', 'content', 'well_type', 'sub_sea', 'entry_date',\n       'completion_date', 'field', 'drill_permit', 'discovery',\n       'discovery_wellbore', 'bottom_hole_temperature', 'site_survey',\n       'seismic_location', 'max_inclation', 'kelly_bush_elevation',\n       'final_vertical_depth', 'total_depth', 'water_depth', 'kick_off_point',\n       'age_at_td', 'formation_at_td', 'main_area', 'drilling_facility',\n       'facility_type_drilling', 'drilling_facility_fixed_or_moveable',\n       'licensing_activity', 'multilateral', 'purpose_planned', 'entry_year',\n       'completion_year', 'reclass_from_wellbore',\n       'reentry_exploration_activity', 'plot_symbol', 'formation_with_hc1',\n       'age_with_hc1', 'formation_with_hc2', 'age_with_hc2',\n       'formation_with_hc3', 'age_with_hc3', 'drilling_days', 'reentry',\n       'licence_target_name', 'plugged_abandon_date', 'plugged_date',\n       'geodetic_datum', 'ns_deg', 'ns_min', 'ns_sec', 'ns_code', 'ew_deg',\n       'ew_min', 'ew_sec', 'ew_code', 'ns_dec_deg', 'ew_des_deg', 'ns_utm',\n       'ew_utm', 'utm_zone', 'name_part1', 'name_part2', 'name_part3',\n       'name_part4', 'name_part5', 'name_part6', 'press_release_url',\n       'fact_page_url', 'fact_map_url', 'diskos_wellbore_type',\n       'diskos_wellbore_parent', 'wdss_qc_date', 'released_date',\n       'date_reclass', 'npdid_wellbore', 'dsc_npdid_discovery', 'npdid_field',\n       'npdid_facility_drilling', 'npdid_wellbore_reclass',\n       'prl_npdid_production_licence', 'npdid_site_survey', 'date_updated',\n       'date_updated_max', 'datesync_npd'],\n      dtype='object')"
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df.columns"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### clean_names (janitor module) - unification of column names"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Space out words by placing a snake between the words so it is nicer to look at the column names"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = (\n",
    "    df.clean_names(case_type=\"snake\")\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "Index(['wellbore_name', 'well', 'drilling_operator', 'production_licence',\n       'purpose', 'status', 'content', 'well_type', 'sub_sea', 'entry_date',\n       'completion_date', 'field', 'drill_permit', 'discovery',\n       'discovery_wellbore', 'bottom_hole_temperature', 'site_survey',\n       'seismic_location', 'max_inclation', 'kelly_bush_elevation',\n       'final_vertical_depth', 'total_depth', 'water_depth', 'kick_off_point',\n       'age_at_td', 'formation_at_td', 'main_area', 'drilling_facility',\n       'facility_type_drilling', 'drilling_facility_fixed_or_moveable',\n       'licensing_activity', 'multilateral', 'purpose_planned', 'entry_year',\n       'completion_year', 'reclass_from_wellbore',\n       'reentry_exploration_activity', 'plot_symbol', 'formation_with_hc1',\n       'age_with_hc1', 'formation_with_hc2', 'age_with_hc2',\n       'formation_with_hc3', 'age_with_hc3', 'drilling_days', 'reentry',\n       'licence_target_name', 'plugged_abandon_date', 'plugged_date',\n       'geodetic_datum', 'ns_deg', 'ns_min', 'ns_sec', 'ns_code', 'ew_deg',\n       'ew_min', 'ew_sec', 'ew_code', 'ns_dec_deg', 'ew_des_deg', 'ns_utm',\n       'ew_utm', 'utm_zone', 'name_part1', 'name_part2', 'name_part3',\n       'name_part4', 'name_part5', 'name_part6', 'press_release_url',\n       'fact_page_url', 'fact_map_url', 'diskos_wellbore_type',\n       'diskos_wellbore_parent', 'wdss_qc_date', 'released_date',\n       'date_reclass', 'npdid_wellbore', 'dsc_npdid_discovery', 'npdid_field',\n       'npdid_facility_drilling', 'npdid_wellbore_reclass',\n       'prl_npdid_production_licence', 'npdid_site_survey', 'date_updated',\n       'date_updated_max', 'datesync_npd'],\n      dtype='object')"
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df.columns"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Select columns with regex - columns that start with ... "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Select columns that start with *well* by applying regex pattern."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_selected = (df.filter(regex=\"^well\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>wellbore_name</th>\n      <th>well</th>\n      <th>well_type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>1/2-1</td>\n      <td>1/2-1</td>\n      <td>EXPLORATION</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>1/2-2</td>\n      <td>1/2-2</td>\n      <td>EXPLORATION</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>1/3-1</td>\n      <td>1/3-1</td>\n      <td>EXPLORATION</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>1/3-2</td>\n      <td>1/3-2</td>\n      <td>EXPLORATION</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>1/3-3</td>\n      <td>1/3-3</td>\n      <td>EXPLORATION</td>\n    </tr>\n  </tbody>\n</table>\n</div>",
      "text/plain": "  wellbore_name   well    well_type\n0         1/2-1  1/2-1  EXPLORATION\n1         1/2-2  1/2-2  EXPLORATION\n2         1/3-1  1/3-1  EXPLORATION\n3         1/3-2  1/3-2  EXPLORATION\n4         1/3-3  1/3-3  EXPLORATION"
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_selected.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### query - filter the dataframe by a value/s from a column of interest "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Filter dataframe by the elements from the list that is a part of the query argument - a list of values. \n",
    "\n",
    "**REMEMBER SINGLE QUOTES WITHIN DOUBLE QUOTES.**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>wellbore_name</th>\n      <th>well_type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>1/2-1</td>\n      <td>EXPLORATION</td>\n    </tr>\n    <tr>\n      <td>1916</td>\n      <td>7324/10-1</td>\n      <td>EXPLORATION</td>\n    </tr>\n  </tbody>\n</table>\n</div>",
      "text/plain": "     wellbore_name    well_type\n0            1/2-1  EXPLORATION\n1916     7324/10-1  EXPLORATION"
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(df\n",
    "  .filter(items=[\"wellbore_name\", \"well_type\"])\n",
    "  .query(\"wellbore_name in ['1/2-1', '7324/10-1']\")\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Filter dataframe by the elements from predefined list that is outside of the function's scope.\n",
    "In this case you need to use @ before the list name."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>wellbore_name</th>\n      <th>well_type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>1/2-1</td>\n      <td>EXPLORATION</td>\n    </tr>\n    <tr>\n      <td>1916</td>\n      <td>7324/10-1</td>\n      <td>EXPLORATION</td>\n    </tr>\n  </tbody>\n</table>\n</div>",
      "text/plain": "     wellbore_name    well_type\n0            1/2-1  EXPLORATION\n1916     7324/10-1  EXPLORATION"
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "well_list = [\"1/2-1\", \"7324/10-1\"]\n",
    "\n",
    "(df\n",
    "  .filter(items=[\"wellbore_name\", \"well_type\"])\n",
    "  .query(\"wellbore_name in @well_list\")\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Summary statistic (min, max, mean, count,...) per group"
   ]
  },
  {
   "cell_type": "markdown",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-15-db0c3844587f>, line 3)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;36m  File \u001b[1;32m\"<ipython-input-15-db0c3844587f>\"\u001b[1;36m, line \u001b[1;32m3\u001b[0m\n\u001b[1;33m    We see that well_bore name was silently dropped since it is a categorical column.\u001b[0m\n\u001b[1;37m         ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "What is the minimum and maximum total_depth grouped by completion_year and sorted by entry_year?\n",
    "\n",
    "We see that well_bore name was silently dropped since it is a categorical column."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>entry_year</th>\n      <th>total_depth_min</th>\n      <th>total_depth_max</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>2019</td>\n      <td>0.0</td>\n      <td>6068.0</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>2018</td>\n      <td>381.0</td>\n      <td>6100.0</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>2017</td>\n      <td>508.0</td>\n      <td>7811.0</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>2016</td>\n      <td>488.0</td>\n      <td>7126.0</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>2015</td>\n      <td>840.0</td>\n      <td>5765.0</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>2014</td>\n      <td>1033.0</td>\n      <td>4889.0</td>\n    </tr>\n    <tr>\n      <td>6</td>\n      <td>2013</td>\n      <td>930.0</td>\n      <td>5634.0</td>\n    </tr>\n    <tr>\n      <td>7</td>\n      <td>2012</td>\n      <td>1640.0</td>\n      <td>5573.0</td>\n    </tr>\n    <tr>\n      <td>8</td>\n      <td>2011</td>\n      <td>1339.0</td>\n      <td>5672.0</td>\n    </tr>\n    <tr>\n      <td>9</td>\n      <td>2010</td>\n      <td>1178.0</td>\n      <td>5738.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>",
      "text/plain": "   entry_year  total_depth_min  total_depth_max\n0        2019              0.0           6068.0\n1        2018            381.0           6100.0\n2        2017            508.0           7811.0\n3        2016            488.0           7126.0\n4        2015            840.0           5765.0\n5        2014           1033.0           4889.0\n6        2013            930.0           5634.0\n7        2012           1640.0           5573.0\n8        2011           1339.0           5672.0\n9        2010           1178.0           5738.0"
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(df\n",
    "  .filter(items=[\"wellbore_name\", \"entry_year\", \"total_depth\"])\n",
    "  .groupby(\"entry_year\")\n",
    "  .agg(\n",
    "    total_depth_min = pd.NamedAgg(column=\"total_depth\", aggfunc=\"min\"),\n",
    "    total_depth_max = pd.NamedAgg(column=\"total_depth\", aggfunc=\"max\")\n",
    "    )\n",
    "  .sort_values(\"entry_year\", ascending = False)\n",
    "  .reset_index()\n",
    "  ).head(10)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}